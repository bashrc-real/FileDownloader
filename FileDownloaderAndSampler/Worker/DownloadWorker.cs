using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Threading;
using System.Threading.Tasks;

namespace FileDownloaderAndSampler.Worker
{
    public class DownloadWorker
    {
        public class DownloadTracker
        {
            public Uri urlToBeDownloaded { get; set; }
            public string filePath { get; set; }
            public Task downloadTask { get; set; }
            public DownloadStatusNotifier statusNotifier { get; set; }
        }

        private readonly INetworkDownloader networkDownloader;
        private readonly ConcurrentQueue<KeyValuePair<Guid, DownloadTracker>> downloadQueue = new ConcurrentQueue<KeyValuePair<Guid, DownloadTracker>>();
        private readonly ConcurrentDictionary<Guid, DownloadTracker> runningTasks = new ConcurrentDictionary<Guid, DownloadTracker>();
        private readonly HashSet<Guid> generatedGuids = new HashSet<Guid>();
        private readonly int maxConcurrentDownload;
        private int runningDownloadCounter = 0;
        private readonly object syncObject = new object();
        private bool isProcessTaskRunning = false;

        public DownloadWorker(INetworkDownloader downloader, int maxConcurrentDownload)
        {
            this.networkDownloader = downloader;
            this.maxConcurrentDownload = maxConcurrentDownload;
        }


        public Guid Add(Uri uriToDownlaod, string fileDownloadPath)
        {
            var result = Guid.NewGuid();
            var tracker = new DownloadTracker
            {
                urlToBeDownloaded = uriToDownlaod,
                filePath = fileDownloadPath,
                statusNotifier = new DownloadStatusNotifier
                {
                    DownloadComplete = this.OnDownloadComplete
                }
            };

            var isQueueEmpty = this.downloadQueue.IsEmpty;
            this.downloadQueue.Enqueue(KeyValuePair.Create(result, tracker));
            if(isQueueEmpty)
            {
                // Two threads can still see the queue as empty unaware of the modification by the other thread.
                // This should work as long as TriggerProcessTask handles concurrency.
                // Also note that this could lead to spawning of multiple tasks but except the original task running the heavy process loop, the other 
                // tasks would return fairly quickly
                Task.Run(()=>TriggerProcessTask()); 
            }
            return result;
        }

        /// <summary>
        /// Gets the status of the task with the given id
        /// </summary>
        /// <returns>The download status.</returns>
        /// <param name="taskId">Task identifier.</param>
        /// <remarks>If the guid is not generated by this instance of the worker, <see cref="KeyNotFoundException"/> will be thrown
        /// If the task was queued but not yet running, a <see cref="=null"/> will be returned</remarks>
        public DownloadTracker GetStatus(Guid taskId)
        {
            if (!this.generatedGuids.Contains(taskId))
            {
                throw new KeyNotFoundException();
            }

            return this.runningTasks[taskId];
        }

        private void TriggerProcessTask()
        {
            if (this.isProcessTaskRunning)
                return;
            lock(this.syncObject)
            {
                if (this.isProcessTaskRunning) return;
                this.isProcessTaskRunning = true;
                this.ProcessTasks();
                this.isProcessTaskRunning = false;   
            }
        }

        /// <summary>
        /// Processes the task list. 
        /// In case the queue is empty the method polls for 30 seconds before retyring
        /// </summary>
        /// <returns>A boolean signalling the loop ended </returns>
        private bool ProcessTasks()
        {
            while (!this.downloadQueue.TryDequeue(out var nextTask))
            {
                var newCounter = Interlocked.Increment(ref this.runningDownloadCounter);
                nextTask.Value.downloadTask = this.networkDownloader.DownloadFile(nextTask.Value.urlToBeDownloaded, nextTask.Value.filePath,
                                                                                  int.MaxValue, nextTask.Value.statusNotifier);
                this.runningTasks.TryAdd(nextTask.Key, nextTask.Value);
                if (newCounter == this.maxConcurrentDownload)
                {
                    return true;
                }
            }

            return true;
        }

        private void OnDownloadComplete()
        {
            var newValue = Interlocked.Decrement(ref this.runningDownloadCounter);
            if (newValue == this.maxConcurrentDownload - 1)
            {
                ProcessTasks();
            }
        }

    }
}
